{"title":"34c3 summary1","slug":"20180102_34c3_1","date":"2018-01-02T06:31:38.000Z","updated":"2018-01-02T06:31:18.214Z","comments":true,"excerpt":"","content":"<h2 id=\"prefix\"><a href=\"#prefix\" class=\"headerlink\" title=\"prefix\"></a>prefix</h2><p>第二次打国际赛，还是菜的不行。跟着学长们一起学了些东西</p>\n<h2 id=\"SimpleGC\"><a href=\"#SimpleGC\" class=\"headerlink\" title=\"SimpleGC\"></a>SimpleGC</h2><p>一个<code>uaf</code>的洞，一开始本地<code>exp</code>写好了，不过加载<code>2-26</code>的库就不行了，之后才知道是线程处理堆的问题，具体</p>\n<p><a href=\"TCMalloc\">http://pages.cs.wisc.edu/~danb/google-perftools-0.98/tcmalloc.html</a></p>\n<p>这个库是2017年10月份发布的，orz</p>\n<h2 id=\"readme-revenge\"><a href=\"#readme-revenge\" class=\"headerlink\" title=\"readme revenge\"></a>readme revenge</h2><p><a href=\"wp1\">https://github.com/r00ta/myWriteUps/tree/master/34C32017/pwn_readme_revenge</a> 里讲的很清除了。</p>\n<p>这是一种方法，做的时候通过不断的填数据(<code>cyclic(size)</code>) 就能达到崩溃，稍微分析一下代码就能够知道怎么控制<code>rip</code>了，但是这里能控制的只有<code>rip</code>，其他寄存器难以控制，无法<code>getshell</code>(笑)，所以可以利用<code>_fortify_fail</code>这个东西(<code>_libc_argv</code>恰好是能覆盖的)，打印出flag来，所以这个题目叫readme(还带revenge)。</p>\n<p>其实这个还能<code>getshell</code>(队长好强)。出题人也没想到能<code>getshell</code>，所以<code>flag</code>是放再全局变量里的。。。</p>\n<p>具体就是找到一个能够控制<code>ax</code>的寄存器的地方，并且能够在这之后执行<code>xhcg eax, esp</code>的一段指令，之后即可<code>rop</code>来<code>getshell</code></p>\n<h2 id=\"wasm\"><a href=\"#wasm\" class=\"headerlink\" title=\"wasm\"></a>wasm</h2><p>一个很奇葩的题（re除了最简单的好像就没个正常的题），找到了开发者的<a href=\"github\">https://github.com/WebAssembly/wabt</a>。</p>\n<p>解码成<code>WebAssembly text format</code>，找到<code>check</code> flag的函数，打工1k行。orz。还是不知道怎么搞，代码太长</p>\n<p>to be continued…</p>\n<h2 id=\"babyvm\"><a href=\"#babyvm\" class=\"headerlink\" title=\"babyvm\"></a>babyvm</h2><p>to be continued…</p>\n","thumbnail":"/img/61739447_p0.jpg","primarycolor":"cyan","accentcolor":"cyan","categories":[{"name":"Binary","path":"api/categories/Binary.json"}],"tags":[{"name":"Pwn","path":"api/tags/Pwn.json"}]}