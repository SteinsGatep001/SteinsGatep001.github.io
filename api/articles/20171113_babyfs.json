{"title":"hitcon2017 babyfs","slug":"20171113_babyfs","date":"2017-11-13T08:58:59.000Z","updated":"2017-11-15T01:44:08.605Z","comments":true,"excerpt":"","content":"<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"http://gcli.cn/2017/11/08/babyfs/#attack-remotely\" target=\"_blank\" rel=\"external\">http://gcli.cn/2017/11/08/babyfs/#attack-remotely</a></p>\n<p>比赛的时候没怎么看，赛后看了下，学了点新姿势，不过还有一些地方不是特别明白</p>\n<h2 id=\"protection\"><a href=\"#protection\" class=\"headerlink\" title=\"protection\"></a>protection</h2><p>保护全开</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Arch:     amd64<span class=\"number\">-64</span>-little</span><br><span class=\"line\">RELRO:    Partial RELRO</span><br><span class=\"line\">Stack:    Canary found</span><br><span class=\"line\">NX:       NX enabled</span><br><span class=\"line\">PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n<h2 id=\"work-flow\"><a href=\"#work-flow\" class=\"headerlink\" title=\"work flow\"></a>work flow</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">+<span class=\"number\">0x00</span> fp</span><br><span class=\"line\">+<span class=\"number\">0x08</span> buf</span><br><span class=\"line\">+<span class=\"number\">0x10</span> filename</span><br><span class=\"line\">+<span class=\"number\">0x50</span> size</span><br><span class=\"line\">+<span class=\"number\">0x58</span> iswrite</span><br></pre></td></tr></table></figure>\n<h3 id=\"Open-open-filename-you-input\"><a href=\"#Open-open-filename-you-input\" class=\"headerlink\" title=\"Open: open filename you input\"></a>Open: open filename you input</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">buf = <span class=\"built_in\">calloc</span>(<span class=\"number\">1</span>, file.size+<span class=\"number\">1</span>);</span><br><span class=\"line\">iswrite=<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Read-read-size-bytes\"><a href=\"#Read-read-size-bytes\" class=\"headerlink\" title=\"Read: read size bytes\"></a>Read: read size bytes</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = read_int()</span><br><span class=\"line\">assert n&lt;=size;</span><br><span class=\"line\">read(n)</span><br><span class=\"line\">fseek <span class=\"number\">0</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"Write-printf\"><a href=\"#Write-printf\" class=\"headerlink\" title=\"Write: printf\"></a>Write: printf</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(!iswrite)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    fwrite(buf)</span><br><span class=\"line\">    iswrite = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Close-check-and-close\"><a href=\"#Close-check-and-close\" class=\"headerlink\" title=\"Close: check and close\"></a>Close: check and close</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(buf) <span class=\"built_in\">free</span>(buf); buf=<span class=\"number\">0</span>;</span><br><span class=\"line\">fp=<span class=\"number\">0</span>; <span class=\"built_in\">memset</span>(filename);</span><br><span class=\"line\">iswrite=<span class=\"number\">0</span>;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Exit-just-exit\"><a href=\"#Exit-just-exit\" class=\"headerlink\" title=\"Exit: just exit\"></a>Exit: just exit</h3><p>none</p>\n<h2 id=\"Vuln\"><a href=\"#Vuln\" class=\"headerlink\" title=\"Vuln\"></a>Vuln</h2><p>在以上所有的操作中，可以发现程序对堆的释放和申请，已经结构体的检测十分严格，无法找出常见的<code>UAF</code>或者<code>offbyone</code>之类的操作</p>\n<p>而程序可以<code>open</code>任意的文件。可以通过<code>fopen(&quot;/dev/stdin&quot;)</code>打开输入缓冲。</p>\n<p>这样打开会发现<code>file.size</code>为<code>-1</code>(0xFFFFFFFFFFFFFFFF)，而之后又调用<code>calloc(1, -1+1)</code>，这样就会申请到一个<code>0x20</code>大小的chunk（注意calloc和malloc是有区别的）。</p>\n<p>显然这里存在着(0xFFFFFFFFFFFFFFFF)大小的堆溢出</p>\n<h2 id=\"filesystem\"><a href=\"#filesystem\" class=\"headerlink\" title=\"filesystem\"></a>filesystem</h2><p>题目名就是<code>filesystem</code>，该题正解就是利用相关的方法，而之前对这个不是很了解，所以要对其进行一些调试。</p>\n<p>首先在调用fopen,malloc,cfree下断点。然后步过fopen，直接在malloc断下了，然后因为是第一次调用malloc，malloc走图中右边，这里还不太清楚。。</p>\n<p><img src=\"/img/hitcon2017_babyfs/fopen_malloc.png\" alt=\"\"></p>\n<p>走完<code>fopen</code>之后出现下面的块，这里就是<code>fopen(&quot;/dev/stdin&quot;)</code>的<code>_IO_FILE</code>了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0000564C9F46C000  0000000000000000 0000000000000231  ........1.......</span><br><span class=\"line\">0000564C9F46C010  00000000FBAD2488 0000000000000000  .$..............</span><br><span class=\"line\">0000564C9F46C020  0000000000000000 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C030  0000000000000000 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C040  0000000000000000 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C050  0000000000000000 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C060  0000000000000000 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C070  0000000000000000 00007F6D2D137540  ........@u.-m...</span><br><span class=\"line\">0000564C9F46C080  0000000000000003 0000000000000000  ................</span><br><span class=\"line\">0000564C9F46C090  0000000000000000 0000564C9F46C0F0  ............LV..</span><br><span class=\"line\">...之后省略</span><br></pre></td></tr></table></figure></p>\n<p>图中<code>0x0000564C9F46C010</code>处的值就是对应<code>_IO_FILE</code>的<code>_flags</code>了</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> &#123;</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _flags;\t\t<span class=\"comment\">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> _IO_file_flags _flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_ptr;\t<span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_end;\t<span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_read_base;\t<span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_base;\t<span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_ptr;\t<span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_write_end;\t<span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_buf_base;\t<span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span>* _IO_buf_end;\t<span class=\"comment\">/* End of reserve area. */</span></span><br><span class=\"line\">  <span class=\"comment\">/* The following fields are used to support backing up and undo. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_save_base; <span class=\"comment\">/* Pointer to start of non-current get area. */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_backup_base;  <span class=\"comment\">/* Pointer to first valid character of backup area */</span></span><br><span class=\"line\">  <span class=\"keyword\">char</span> *_IO_save_end; <span class=\"comment\">/* Pointer to end of non-current get area. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_marker</span> *_<span class=\"title\">markers</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _fileno;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">if</span> 0</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _blksize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> _flags2;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br><span class=\"line\">  _IO_off_t _old_offset; <span class=\"comment\">/* This used to be _offset but it's too small.  */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> __HAVE_COLUMN <span class=\"comment\">/* temporary */</span></span></span><br><span class=\"line\">  <span class=\"comment\">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">short</span> _cur_column;</span><br><span class=\"line\">  <span class=\"keyword\">signed</span> <span class=\"keyword\">char</span> _vtable_offset;</span><br><span class=\"line\">  <span class=\"keyword\">char</span> _shortbuf[<span class=\"number\">1</span>];</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_lock_t *_lock;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p><a href=\"http://sourceware.org/git/?p=glibc.git;a=blob_plain;f=libio/libio.h;hb=4f2b767fef50f5f5c356c0c0e424fccc893a4ae6\" target=\"_blank\" rel=\"external\">glibc io_file</a> 有其结构</p>\n<p>在知道了上面的知识<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fopen(&quot;/dev/stdin&quot;, &quot;r&quot;)</span><br><span class=\"line\">fopen(&quot;/dev/stdout&quot;, &quot;r&quot;)</span><br><span class=\"line\">// 然后调用read读取stdin，就能对file对_IO_FILE结构进行任意写</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h2><p>在能随意修改结构体之后，需要想怎么<code>leak</code>出堆和<code>libc</code>的地址。</p>\n<p>在文件关闭的时候，如果文件是以w方式打开，libc就会把_IO_write_base到_IO_write_end写进文件。所以只要更改_IO_write_base，然后关闭stdout文件，最后就能leak出一些东西了。</p>\n<p>不过因为程序都是以<code>r</code>方式打开文件，所以需要修改<code>stdout</code>的<code>_fileno</code>为2(标准输出)，然后在关闭文件的时候，就会将<code>_IO_write_end</code>写入<code>stdout</code>，从而泄露地址。</p>\n<p>不过要覆盖这个地方，前面的<code>_IO_write_end</code>必然会破坏，这里就要用fseek进行恢复指针</p>\n<p>还有要注意的是<code>__IO_FILE</code>中<code>_flags</code>，低16位是有关文件属性的标志位，具体含义如下</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define __SLBF  0x0001          /* line buffered */</span><br><span class=\"line\">#define __SNBF  0x0002          /* unbuffered */</span><br><span class=\"line\">#define __SRD   0x0004          /* OK to read */</span><br><span class=\"line\">#define __SWR   0x0008          /* OK to write */</span><br><span class=\"line\">        /* RD and WR are never simultaneously asserted */</span><br><span class=\"line\">#define __SRW   0x0010          /* open for reading &amp; writing */</span><br><span class=\"line\">#define __SEOF  0x0020          /* found EOF */</span><br><span class=\"line\">#define __SERR  0x0040          /* found error */</span><br><span class=\"line\">#define __SMBF  0x0080          /* _buf is from malloc */</span><br><span class=\"line\">#define __SAPP  0x0100          /* fdopen()ed in append mode - so must  write to end */</span><br><span class=\"line\">#define __SSTR  0x0200          /* this is an sprintf/snprintf string */</span><br><span class=\"line\">#define __SOPT  0x0400          /* do fseek() optimisation */</span><br><span class=\"line\">#define __SNPT  0x0800          /* do not do fseek() optimisation */</span><br><span class=\"line\">#define __SOFF  0x1000          /* set iff _offset is in fact correct */</span><br><span class=\"line\">#define __SMOD  0x2000          /* true =&gt; fgetline modified _p text */</span><br></pre></td></tr></table></figure>\n<p>经过调试<code>fread(file, &quot;w&quot;)</code>对应<code>0xfbad2484</code>(高16位固定)，exploit中是<code>0xfbad3887</code>？？？？？？ 这里不是很清楚。</p>\n<p>将<code>fseek()</code>改成了不优化，增加了<code>unbuffered</code>和<code>line buffered</code></p>\n<p>调试发现这些位都必须设置，并且<strong>SNBF设置之后，<code>fseek</code>恢复的指针才指向`</strong>IO_FILE`(第二个file)的附近，之后才能利用 partical overwrite。</p>\n<p>最后在fclose的时候，必然会有写文件操作，这样就把<code>_IO_write_base</code>指向的值一直到<code>_IO_write_end</code>输出到文件(<code>/dev/stdout</code>)，即输出到标准输出了(注意这里还必须保证<code>_fileno</code>是2)</p>\n<h2 id=\"Exploit\"><a href=\"#Exploit\" class=\"headerlink\" title=\"Exploit\"></a>Exploit</h2><p>最后拿shell就比较简单了，直接修改<code>_IO_buf_base</code>和<code>_IO_buf_end</code>到<strong>free_hook或者</strong>malloc_hook，然后fread一下即可修改对应指针。</p>\n<p>然后fclose到时候会调用一下malloc，即可起shell。不过好像是因为对stdout对操作，最后可能程序的printf不出东西，所以最后shell要稍微做个反弹的操作。</p>\n<h3 id=\"remote\"><a href=\"#remote\" class=\"headerlink\" title=\"remote\"></a>remote</h3><p>最后在远程的时候还要注意 <code>,pty,ctty,echo=0</code> ，会过滤 ‘\\x7f’，通过 ‘\\x16\\x7f’替代即可。</p>\n","thumbnail":"/img/61739447_p0.jpg","primarycolor":"cyan","accentcolor":"cyan","categories":[{"name":"Binary","path":"api/categories/Binary.json"}],"tags":[{"name":"Pwn","path":"api/tags/Pwn.json"}]}