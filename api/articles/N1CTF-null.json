{"title":"N1CTF_null","slug":"N1CTF-null","date":"2018-03-21T01:57:49.000Z","updated":"2018-03-21T02:00:37.825Z","comments":true,"excerpt":"","content":"<h2 id=\"vuln\"><a href=\"#vuln\" class=\"headerlink\" title=\"vuln\"></a>vuln</h2><p>Overflow in read function</p>\n<h2 id=\"malloc-in-thread\"><a href=\"#malloc-in-thread\" class=\"headerlink\" title=\"malloc in thread\"></a>malloc in thread</h2><h3 id=\"thread-arena\"><a href=\"#thread-arena\" class=\"headerlink\" title=\"thread arena\"></a>thread arena</h3><p>before malloc, segments algin as below<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Start              End                Offset             Perm Path</span><br><span class=\"line\">0x0000000000400000 0x0000000000402000 0x0000000000000000 r-x /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000601000 0x0000000000602000 0x0000000000001000 r-- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000602000 0x0000000000603000 0x0000000000002000 rw- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x000000000139b000 0x00000000013bc000 0x0000000000000000 rw- [heap]</span><br><span class=\"line\">0x00007f87835e1000 0x00007f87835e2000 0x0000000000000000 ---</span><br><span class=\"line\">0x00007f87835e2000 0x00007f8783de2000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007f8783de2000 0x00007f8783fa2000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f8783fa2000 0x00007f87841a2000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f87841a2000 0x00007f87841a6000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f87841a6000 0x00007f87841a8000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br></pre></td></tr></table></figure></p>\n<p>we all know <code>malloc</code> call <code>__libc_malloc</code>, so let’s read source code in  <code>__libc_malloc</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"keyword\">if</span> (SINGLE_THREAD_P)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      victim = _int_malloc (&amp;main_arena, bytes);</span><br><span class=\"line\">      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||</span><br><span class=\"line\">              &amp;main_arena == arena_for_chunk (mem2chunk (victim)));</span><br><span class=\"line\">      <span class=\"keyword\">return</span> victim;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  arena_get (ar_ptr, bytes);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* arena_get() acquires an arena and locks the corresponding mutex.</span></span><br><span class=\"line\"><span class=\"comment\">   First, try the one last locked successfully by this thread.  (This</span></span><br><span class=\"line\"><span class=\"comment\">   is the common case and handled with a macro for speed.)  Then, loop</span></span><br><span class=\"line\"><span class=\"comment\">   once over the circularly linked list of arenas.  If no arena is</span></span><br><span class=\"line\"><span class=\"comment\">   readily available, create a new one.  In this latter case, `size'</span></span><br><span class=\"line\"><span class=\"comment\">   is just a hint as to how much memory will be required immediately</span></span><br><span class=\"line\"><span class=\"comment\">   in the new arena. */</span></span><br></pre></td></tr></table></figure>\n<p>notice that in sub thread, we use <code>arena_get</code>. when after first call of <code>arena_get</code>, segments algin as below</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Start              End                Offset             Perm Path</span><br><span class=\"line\">0x0000000000400000 0x0000000000402000 0x0000000000000000 r-x /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000601000 0x0000000000602000 0x0000000000001000 r-- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000602000 0x0000000000603000 0x0000000000002000 rw- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x000000000139b000 0x00000000013bc000 0x0000000000000000 rw- [heap]</span><br><span class=\"line\">0x00007f877c000000 0x00007f877c021000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007f877c021000 0x00007f8780000000 0x0000000000000000 ---</span><br><span class=\"line\">0x00007f87835e1000 0x00007f87835e2000 0x0000000000000000 ---</span><br><span class=\"line\">0x00007f87835e2000 0x00007f8783de2000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007f8783de2000 0x00007f8783fa2000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f8783fa2000 0x00007f87841a2000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f87841a2000 0x00007f87841a6000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007f87841a6000 0x00007f87841a8000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br></pre></td></tr></table></figure>\n<p>We found that 1 segment has been added. The <code>0x00007fa0bc000000 - 0x00007f10fc021000</code> segment is for <code>thread_arena</code>. And malloc return address after the <code>thread_arena</code></p>\n<h3 id=\"thread-chunk\"><a href=\"#thread-chunk\" class=\"headerlink\" title=\"thread chunk\"></a>thread chunk</h3><p>then system use <code>_int_malloc</code> to alloc chunk for user</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gef➤  p thread_arena</span><br><span class=\"line\">$<span class=\"number\">5</span> = (mstate) <span class=\"number\">0x7f877c000020</span></span><br><span class=\"line\">gef➤  p $rax</span><br><span class=\"line\">$<span class=\"number\">6</span> = <span class=\"number\">0x7f877c0008c0</span></span><br></pre></td></tr></table></figure>\n<p>the chunk is just after <code>chunk thread_arena</code></p>\n<h2 id=\"heap-mmap\"><a href=\"#heap-mmap\" class=\"headerlink\" title=\"heap mmap\"></a>heap mmap</h2><p>As showed above, we know how libc alloc thread chunk. But how does libc alloc next segment for thread chunk while the first segment is fill?</p>\n<p>After debugging, we found the alloc of second segment likes the first one. The second one and the first one could be continuous with each other, as the <a href=\"https://gist.github.com/romanking98/630f2b3c7216ae389f4ea3ce551041e1\" target=\"_blank\" rel=\"external\">blog</a> said.</p>\n<p>The critical point is that the returned address of heap mmap decreases. So the second mmap segment is front of the <code>thread_arena</code> segment.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Start              End                Offset             Perm Path</span><br><span class=\"line\">0x0000000000400000 0x0000000000402000 0x0000000000000000 r-x /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000601000 0x0000000000602000 0x0000000000001000 r-- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000000602000 0x0000000000603000 0x0000000000002000 rw- /home/d3adf1sh/CTFs/null_dir/null</span><br><span class=\"line\">0x0000000001711000 0x0000000001732000 0x0000000000000000 rw- [heap]</span><br><span class=\"line\">0x00007fc2e0000000 0x00007fc2e8000000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007fc2e8000000 0x00007fc2ebffd000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007fc2ebffd000 0x00007fc2ec000000 0x0000000000000000 ---</span><br><span class=\"line\">0x00007fc2ec2cf000 0x00007fc2ec2d0000 0x0000000000000000 ---</span><br><span class=\"line\">0x00007fc2ec2d0000 0x00007fc2ecad0000 0x0000000000000000 rw-</span><br><span class=\"line\">0x00007fc2ecad0000 0x00007fc2ecc90000 0x0000000000000000 r-x /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007fc2ecc90000 0x00007fc2ece90000 0x00000000001c0000 --- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007fc2ece90000 0x00007fc2ece94000 0x00000000001c0000 r-- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">0x00007fc2ece94000 0x00007fc2ece96000 0x00000000001c4000 rw- /lib/x86_64-linux-gnu/libc-2.23.so</span><br><span class=\"line\">...</span><br><span class=\"line\">gef➤  p $rax</span><br><span class=\"line\">$10 = 0x7fc2e7ffbc70</span><br><span class=\"line\">gef➤  p thread_arena</span><br><span class=\"line\">$11 = (mstate) 0x7fc2e8000020</span><br></pre></td></tr></table></figure>\n<h2 id=\"overwrite-thread-arena\"><a href=\"#overwrite-thread-arena\" class=\"headerlink\" title=\"overwrite thread_arena\"></a>overwrite thread_arena</h2><p>let’s deep in the struct of <code>thread_arena</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Serialize access.  */</span></span><br><span class=\"line\">  __libc_lock_define (, mutex);</span><br><span class=\"line\">  <span class=\"comment\">/* Flags (formerly in max_fast).  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> flags;</span><br><span class=\"line\">  <span class=\"comment\">/* Set if the fastbin chunks contain recently inserted free blocks.  */</span></span><br><span class=\"line\">  <span class=\"comment\">/* Note this is a bool but not all targets support atomics on booleans.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> have_fastchunks;</span><br><span class=\"line\">  <span class=\"comment\">/* Fastbins */</span></span><br><span class=\"line\">  mfastbinptr fastbinsY[NFASTBINS];</span><br><span class=\"line\">  <span class=\"comment\">/* Base of the topmost chunk -- not otherwise kept in a bin */</span></span><br><span class=\"line\">  mchunkptr top;</span><br><span class=\"line\">  <span class=\"comment\">/* The remainder from the most recent split of a small request */</span></span><br><span class=\"line\">  mchunkptr last_remainder;</span><br><span class=\"line\">  <span class=\"comment\">/* Normal bins packed as described above */</span></span><br><span class=\"line\">  mchunkptr bins[NBINS * <span class=\"number\">2</span> - <span class=\"number\">2</span>];</span><br><span class=\"line\">  <span class=\"comment\">/* Bitmap of bins */</span></span><br><span class=\"line\">  <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> binmap[BINMAPSIZE];</span><br><span class=\"line\">  <span class=\"comment\">/* Linked list */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Linked list for free arenas.  Access to this field is serialized</span></span><br><span class=\"line\"><span class=\"comment\">     by free_list_lock in arena.c.  */</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_state</span> *<span class=\"title\">next_free</span>;</span></span><br><span class=\"line\">  <span class=\"comment\">/* Number of threads attached to this arena.  0 if the arena is on</span></span><br><span class=\"line\"><span class=\"comment\">     the free list.  Access to this field is serialized by</span></span><br><span class=\"line\"><span class=\"comment\">     free_list_lock in arena.c.  */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T attached_threads;</span><br><span class=\"line\">  <span class=\"comment\">/* Memory allocated from the system in this arena.  */</span></span><br><span class=\"line\">  INTERNAL_SIZE_T system_mem;</span><br><span class=\"line\">  INTERNAL_SIZE_T max_system_mem;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<p>the comment is very clear. We can find fake chunk at bss by shifting data, so just overwrite <code>fastbinsY</code> fastbin to bss, and malloc, then we will get fake chunk before bss.</p>\n<h2 id=\"Reference\"><a href=\"#Reference\" class=\"headerlink\" title=\"Reference\"></a>Reference</h2><p><a href=\"https://code.woboq.org/userspace/glibc/malloc/malloc.c.html#3026\" target=\"_blank\" rel=\"external\"><code>__libc_malloc</code></a><br><a href=\"https://gist.github.com/romanking98/630f2b3c7216ae389f4ea3ce551041e1\" target=\"_blank\" rel=\"external\">null wp</a></p>\n","categories":[],"tags":[]}