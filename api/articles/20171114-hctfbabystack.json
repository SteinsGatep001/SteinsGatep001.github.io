{"title":"20171114_hctfbabystack","slug":"20171114-hctfbabystack","date":"2017-11-14T14:05:34.000Z","updated":"2017-11-14T14:14:14.034Z","comments":true,"excerpt":"","content":"<h2 id=\"check\"><a href=\"#check\" class=\"headerlink\" title=\"check\"></a>check</h2><p>程序的逻辑很简单，明显的栈溢出，然后加一个seccomp。</p>\n<p>能用的函数只有</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read</span><br><span class=\"line\">open</span><br><span class=\"line\"><span class=\"built_in\">exit</span></span><br></pre></td></tr></table></figure>\n<p>然后保护就一个NX</p>\n<h2 id=\"think\"><a href=\"#think\" class=\"headerlink\" title=\"think\"></a>think</h2><p>首先当然是leak出libc的地址。</p>\n<h3 id=\"弯路\"><a href=\"#弯路\" class=\"headerlink\" title=\"弯路\"></a>弯路</h3><p>其实也想过用seccomp_reset()，来进行绕过。</p>\n<p>但是观察了栈分配，要造成溢出必然要把seccomp的ctx值给覆盖了，所以无法获取ctx，这个方法不可行</p>\n<h3 id=\"right\"><a href=\"#right\" class=\"headerlink\" title=\"right\"></a>right</h3><p>既然程序只给这几个函数，必然是有原因的。</p>\n<p>很容易写rop把flag文件打开，然后read到bss段。</p>\n<p>但是！！！没有输出。这就很尴尬了。。。</p>\n<p>后来想了想，可以用爆破的方法，在libc找个指令，cmp什么的。</p>\n<p>在一番搜索之后，发现下面的rop</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000000D72CE                 cmp     cl, [rsi]</span><br><span class=\"line\">.text:00000000000D72D0                 jz      short loc_D7266</span><br><span class=\"line\">.text:00000000000D72D2                 pop     rbx</span><br><span class=\"line\">.text:00000000000D72D3                 retn</span><br></pre></td></tr></table></figure>\n<p>这就很有趣了，只要把cl弄成猜的值，rsi指向bss读取的flag，一旦相等，程序就会jz，然后直接挂了。如果猜的不对，我们可以利用read的阻塞。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read(0, bss+0x10, 0x1000)</span><br></pre></td></tr></table></figure>\n<p>这样程序就会阻塞，只要写个</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">try:</span><br><span class=\"line\">    io.send(&apos;a&apos;*0x100)</span><br><span class=\"line\">except:</span><br><span class=\"line\">    log.success(str(offset)+&quot;, is &quot;+chr(bval))</span><br><span class=\"line\">    return True</span><br></pre></td></tr></table></figure>\n<p>之后依次爆破即可</p>\n","categories":[],"tags":[{"name":"Pwn","path":"api/tags/Pwn.json"}]}